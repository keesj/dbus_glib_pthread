/* Generated by dbus-binding-tool; do not edit! */

#include <glib.h>
#include <dbus/dbus-glib.h>

G_BEGIN_DECLS
#ifndef _DBUS_GLIB_ASYNC_DATA_FREE
#define _DBUS_GLIB_ASYNC_DATA_FREE
    static
#ifdef G_HAVE_INLINE
 inline
#endif
void _dbus_glib_async_data_free(gpointer stuff)
{
    g_slice_free(DBusGAsyncData, stuff);
}
#endif

#ifndef DBUS_GLIB_CLIENT_WRAPPERS_com_test_EchoService
#define DBUS_GLIB_CLIENT_WRAPPERS_com_test_EchoService

static
#ifdef G_HAVE_INLINE
 inline
#endif
 gboolean
com_test_EchoService_echo(DBusGProxy * proxy, const char *IN_in,
			  char **OUT_out, GError ** error)
{
    return dbus_g_proxy_call(proxy, "echo", error, G_TYPE_STRING, IN_in,
			     G_TYPE_INVALID, G_TYPE_STRING, OUT_out,
			     G_TYPE_INVALID);
}

typedef void (*com_test_EchoService_echo_reply) (DBusGProxy * proxy,
						 char *OUT_out,
						 GError * error,
						 gpointer userdata);

static void
com_test_EchoService_echo_async_callback(DBusGProxy * proxy,
					 DBusGProxyCall * call,
					 void *user_data)
{
    DBusGAsyncData *data = (DBusGAsyncData *) user_data;
    GError *error = NULL;
    char *OUT_out;
    dbus_g_proxy_end_call(proxy, call, &error, G_TYPE_STRING, &OUT_out,
			  G_TYPE_INVALID);
    (*(com_test_EchoService_echo_reply) data->cb) (proxy, OUT_out, error,
						   data->userdata);
    return;
}

static
#ifdef G_HAVE_INLINE
 inline
#endif
 DBusGProxyCall *
com_test_EchoService_echo_async(DBusGProxy * proxy, const char *IN_in,
				com_test_EchoService_echo_reply callback,
				gpointer userdata)
{
    DBusGAsyncData *stuff;
    stuff = g_slice_new(DBusGAsyncData);
    stuff->cb = G_CALLBACK(callback);
    stuff->userdata = userdata;
    return dbus_g_proxy_begin_call(proxy, "echo",
				   com_test_EchoService_echo_async_callback,
				   stuff, _dbus_glib_async_data_free,
				   G_TYPE_STRING, IN_in, G_TYPE_INVALID);
}
#endif				/* defined DBUS_GLIB_CLIENT_WRAPPERS_com_test_EchoService */

G_END_DECLS
